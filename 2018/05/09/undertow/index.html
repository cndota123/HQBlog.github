<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>undertow | HQ BLOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="undertow简介Undertow是RedHat的开源产品，是WildFly8（JBoos）默认的Web服务器。 官方定义：Undertow is a flexible performant web server written in java, providing both blocking and non-blocking API’s based on NIO(Undertow是一个用jav">
<meta property="og:type" content="article">
<meta property="og:title" content="undertow">
<meta property="og:url" content="http://yoursite.com/2018/05/09/undertow/index.html">
<meta property="og:site_name" content="HQ BLOG">
<meta property="og:description" content="undertow简介Undertow是RedHat的开源产品，是WildFly8（JBoos）默认的Web服务器。 官方定义：Undertow is a flexible performant web server written in java, providing both blocking and non-blocking API’s based on NIO(Undertow是一个用jav">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-08-28T14:46:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="undertow">
<meta name="twitter:description" content="undertow简介Undertow是RedHat的开源产品，是WildFly8（JBoos）默认的Web服务器。 官方定义：Undertow is a flexible performant web server written in java, providing both blocking and non-blocking API’s based on NIO(Undertow是一个用jav">
  
    <link rel="alternate" href="/atom.xml" title="HQ BLOG" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HQ BLOG</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-undertow" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/09/undertow/" class="article-date">
  <time datetime="2018-05-09T14:04:26.000Z" itemprop="datePublished">2018-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      undertow
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="undertow简介"><a href="#undertow简介" class="headerlink" title="undertow简介"></a>undertow简介</h2><p>Undertow是RedHat的开源产品，是WildFly8（JBoos）默认的Web服务器。</p>
<p>官方定义：<br>Undertow is a flexible performant web server written in java, providing both blocking and non-blocking API’s based on NIO(Undertow是一个用java编写的灵活的高性能Web服务器，提供基于NIO的阻塞和非阻塞API.).</p>
<p>总结它有以下个特点：</p>
<ul>
<li>HTTP/2 Support<ul>
<li>Undertow非常轻量级，Undertow核心jar包在1Mb以下。它在运行时也是轻量级的，有一个简单的嵌入式服务器使用少于4Mb的堆空间</li>
</ul>
</li>
<li>HTTP Upgrade Support（支持http升级）<ul>
<li>支持HTTP升级，允许多个协议通过HTTP端口进行多路复用</li>
</ul>
</li>
<li>Web Socket Support（支持WebScoket）<ul>
<li>Undertow提供对Web Socket的全面支持，包括JSR-356支持</li>
</ul>
</li>
<li>Servlet 4.0<ul>
<li>Undertow提供对Servlet 4.0的支持，包括对嵌入式servlet的支持。 还可以在同一部署中混合Servlet和本机Undertow非阻塞处理程序</li>
</ul>
</li>
<li>Embeddable（可嵌入的）<ul>
<li>Undertow可以嵌入在应用程序中或独立运行，只需几行代码</li>
</ul>
</li>
<li>Flexible（灵活性）<ul>
<li>Undertow框架jar包： undertow-core.jar undertow-servlet.jar,不需要的库可以不用</li>
</ul>
</li>
</ul>
<h3 id="undertow设计初衷"><a href="#undertow设计初衷" class="headerlink" title="undertow设计初衷"></a>undertow设计初衷</h3><ol>
<li>更好的满足JBoss应用服务器的集成需要。Tomcat最初设计于10年前，体系结构没有办法进行灵活的修改。在和JBoss应用服务器集成时，需要写大量的组合代码使得Tomcat和JBossAS协同工作。</li>
<li>嵌入式需求。不论是JBoss应用服务器本身，还是目前微服务(MicroService)的设计倾向，都希望能够web容器足够小而精悍，可以嵌入使用，而Tomcat很难满足这个需要。</li>
<li>支持Websocket协议需求和NIO，异步化思路等的促进。异步通信框架在并发连接数，性能的优异表现促使开发人员想重新按照新的思路来设计一款Web服务器。</li>
</ol>
<h3 id="undertow性能"><a href="#undertow性能" class="headerlink" title="undertow性能"></a>undertow性能</h3><p>在Undertow刚发布beta版时，参加了由Techempower设计的著名框架集合性能测试竞赛，在纯文本EC2服务上一举拿下第一<br><a href="http://www.techempower.com/benchmarks/#section=data-r6&amp;hw=ec2&amp;test=plaintext" target="_blank" rel="noopener">Web Framework Benchmarks</a></p>
<h2 id="undertow使用"><a href="#undertow使用" class="headerlink" title="undertow使用"></a>undertow使用</h2><h3 id="一个简单的undertow服务"><a href="#一个简单的undertow服务" class="headerlink" title="一个简单的undertow服务"></a>一个简单的undertow服务</h3><p>下面是官方文档给出的一个简单的使用demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Undertow server = Undertow.builder().addHttpListener(<span class="number">8090</span>,<span class="string">"localhost"</span>)</span><br><span class="line">            .setHandler(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    httpServerExchange.getResponseHeaders().put(Headers.CONTENT_TYPE,<span class="string">"text/plain"</span>);</span><br><span class="line">                    httpServerExchange.getResponseSender().send(<span class="string">"hello world"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).build();</span><br><span class="line">    server.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Undertow.builder()快速配置和启动Undertow服务器，addHttpListener()告诉服务器Undertow服务器在端口8090绑定到localhost，HttpHandler是一个内置处理程序接口，它有各种各样的实现来实现不同功能。在这个demo中修改response的header和body返回hello world。</p>
<h3 id="手动组装服务器"><a href="#手动组装服务器" class="headerlink" title="手动组装服务器"></a>手动组装服务器</h3><p>Undertow.builder()提供了一个快捷的服务器构建方式，不过我们也可以手动组装服务器，这样有更大的自由度。<br>官网对于这种方式介绍含有以下描述：</p>
<ul>
<li>完全控制所有选项</li>
<li>能够为每个listener使用不同的缓冲池和工作者</li>
<li>XnioWorker实例可以在不同的服务器实例之间共享</li>
<li>缓冲池可以在不同的服务器实例之间共享</li>
<li>听众可以被赋予不同的根处理程序</li>
</ul>
<p>不过在大多数情况下，这种控制级别是不必要的，最好是简单地使用构建器API。</p>
<p>下面给出一个Http listener类型的demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Xnio xnio = Xnio.getInstance();</span><br><span class="line">XnioWorker worker = xnio.createWorker(OptionMap.builder()</span><br><span class="line">        .set(Options.WORKER_IO_THREADS,<span class="number">8</span>)</span><br><span class="line">        .set(Options.WORKER_TASK_CORE_THREADS,<span class="number">40</span>)</span><br><span class="line">        .set(Options.WORKER_TASK_MAX_THREADS,<span class="number">10</span>)</span><br><span class="line">        .set(Options.TCP_NODELAY,<span class="keyword">true</span>)</span><br><span class="line">        .getMap()</span><br><span class="line">);</span><br><span class="line">OptionMap socketOptions = OptionMap.builder()</span><br><span class="line">        .set(Options.WORKER_IO_THREADS, <span class="number">5</span>)</span><br><span class="line">        .set(Options.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">        .set(Options.REUSE_ADDRESSES, <span class="keyword">true</span>)</span><br><span class="line">        .getMap();</span><br><span class="line">Pool&lt;ByteBuffer&gt; buffers = <span class="keyword">new</span> ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR,<span class="number">1024</span>, <span class="number">16</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">HttpOpenListener openListener = <span class="keyword">new</span> HttpOpenListener(buffers,OptionMap.builder().set(UndertowOptions.BUFFER_PIPELINED_DATA,<span class="keyword">true</span>)</span><br><span class="line">        .addAll(socketOptions).getMap());</span><br><span class="line">openListener.setRootHandler(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        httpServerExchange.getResponseHeaders().put(Headers.CONTENT_TYPE,<span class="string">"text/plain"</span>);</span><br><span class="line">        httpServerExchange.getResponseSender().send(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ChannelListener&lt;AcceptingChannel&lt;StreamConnection&gt;&gt; channelListener = ChannelListeners.openListenerAdapter(openListener);</span><br><span class="line">AcceptingChannel&lt;? extends StreamConnection&gt; server = worker.createStreamConnectionServer(<span class="keyword">new</span> InetSocketAddress(Inet4Address.getByName(<span class="string">"localhost"</span>),<span class="number">8098</span>),channelListener,socketOptions);</span><br><span class="line">server.resumeAccepts();</span><br></pre></td></tr></table></figure></p>
<p>上述demo实现功能和利用Undertow.buider()构建的服务器实现能相同。<br>其中有几个比较重要的概念：</p>
<ol>
<li>WORKER_IO_THREADS:要创建的IO线程数，IO线程执行非堵塞任务，并且不应该执行阻塞操作，因为他们负责多个连接，一旦堵塞有的连接就要挂起，每个cpu内核有两个IO线程是合理的</li>
<li>WORKER_TASK_CORE_THREADS:工作线程阻塞任务线程池中的线程数，当执行堵塞操作时，任务分配给该线程池中的线程</li>
</ol>
<h3 id="undertow架构"><a href="#undertow架构" class="headerlink" title="undertow架构"></a>undertow架构</h3><p>通过以上demo对于undertow也有了一个初步的了解。Undertow独特之处在于它没有global container，对于global container我的理解是例如tomcat就利用容器来处理用户请求，至于是不是一个容器管理所有功能还是多个容器协同工作不作考虑，在undertow中服务器由嵌入式应用程序组装而成，这使得Undertow非常灵活，嵌入式应用程序基本可以选择他们需要的那一部分，然后合理组装。</p>
<p>上面demo也体现了这一点我们只是获取Xnio实例，创建了一些操作实例来处理请求，并没有新建容器或是配置容器功能，undertow仅仅是按规则将一些功能类组合起来使用。<br>Undertow服务器基本由三件事组成，一个（或多个）XNIO工作者实例，一个或多个连接器和处理传入请求的处理程序链。</p>
<h3 id="undertow处理程序"><a href="#undertow处理程序" class="headerlink" title="undertow处理程序"></a>undertow处理程序</h3><p>业务功能和服务器逻辑功能的实现通常通过处理程序来实现，处理的程序接口代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange exchange)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>handleRequest方法是处理程序的具体实现，HttpServerExchange有请求的所有上下文信息。<br>如下demo中我们可以自定义一个HttpHandler<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpHandler</span> <span class="keyword">implements</span> <span class="title">HttpHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpString header;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpHandler next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHttpHandler</span><span class="params">(<span class="keyword">final</span> HttpHandler next,<span class="keyword">final</span> String header,<span class="keyword">final</span> String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.header = <span class="keyword">new</span> HttpString(header);</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        httpServerExchange.getResponseHeaders().put(header,value);</span><br><span class="line">        next.handleRequest(httpServerExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    openListener.setRootHandler(<span class="keyword">new</span> MyHttpHandler(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            httpServerExchange.getResponseSender().send(<span class="string">"hello world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">"CONTENT_TYPE"</span>,<span class="string">"text/plain"</span>));</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>上述demo实现的功能和之前demo相同，同时这也是一种处理程序链实现方案。<br>另外一种是通过HttpServerExchange的dispatch方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">openListener.setRootHandler(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        httpServerExchange.getResponseHeaders().put(Headers.CONTENT_TYPE,<span class="string">"text/plain"</span>);</span><br><span class="line">        <span class="keyword">if</span> (httpServerExchange.isInIoThread())&#123;</span><br><span class="line">            httpServerExchange.dispatch(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    httpServerExchange.startBlocking();</span><br><span class="line">                    httpServerExchange.getOutputStream().write(<span class="string">"hello "</span>.getBytes());</span><br><span class="line">                    httpServerExchange.dispatch(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            httpServerExchange.getOutputStream().write(<span class="string">"world"</span>.getBytes());</span><br><span class="line">                            httpServerExchange.endExchange();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>同样这个服务器也实现了返回hello world的功能。</p>
<h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>Undertow有四种监听器（官网说有5种但也只给了四个）：</p>
<ul>
<li>HTTP / 1.1</li>
<li>HTTPS</li>
<li>AJP</li>
<li>HTTP / 2<br>他们的差别主要在构建的时候listener类型的选择，其中比较典型是HTTP2需要ALPN的支持（java 9自带），同时HTTP2支持Http Upgrade</li>
</ul>
<h3 id="Undertow-Servlet"><a href="#Undertow-Servlet" class="headerlink" title="Undertow Servlet"></a>Undertow Servlet</h3><p>Undertow也可以配合servlet使用，这里提供一个简单的demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    DeploymentInfo servletBuilder = Servlets.deployment()</span><br><span class="line">            .setClassLoader(ServletServer.class.getClassLoader())</span><br><span class="line">            .setContextPath(<span class="string">"/servlet"</span>)</span><br><span class="line">            .setDeploymentName(<span class="string">"test.war"</span>)</span><br><span class="line">            .addServlets(</span><br><span class="line">                    Servlets.servlet(<span class="string">"myServlet"</span>,MyServlet.class)</span><br><span class="line">                    .addInitParam(<span class="string">"message"</span>,<span class="string">"MyServlet"</span>)</span><br><span class="line">                    .addMapping(<span class="string">"/myServlet"</span>)</span><br><span class="line">            );</span><br><span class="line">    DeploymentManager manager = Servlets.defaultContainer().addDeployment(servletBuilder);</span><br><span class="line">    manager.deploy();</span><br><span class="line">    PathHandler path = Handlers.path(Handlers.redirect(<span class="string">"/myapp"</span>))</span><br><span class="line">            .addPrefixPath(<span class="string">"/myapp"</span>, manager.start());</span><br><span class="line">    Undertow server = Undertow.builder().addHttpListener(<span class="number">8094</span>,<span class="string">"localhost"</span>).setHandler(path).build();</span><br><span class="line">    server.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MyServlet是自己定义的一个servlet<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        response.setHeader(<span class="string">"CONTENT_TYPE"</span>,<span class="string">"text/plain"</span>);</span><br><span class="line">        OutputStream out = response.getOutputStream();</span><br><span class="line">        out.write(<span class="string">"hello world"</span>.getBytes());</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个demo功能也是返回hello world不过它配置了前缀路径和servlet匹配路径，所以访问路径和之前有所不同。</p>
<p>这只是Undertow配合servlet的一个小小的应用，Undertow还支持各种扩展功能，例如资源管理器，认证机制等，在这就不一一叙述，在<a href="http://undertow.io/undertow-docs/undertow-docs-2.0.0/index.html#undertow-servlet" target="_blank" rel="noopener">官方文档</a>有相关描述</p>
<h3 id="Undertow-Spring-boot"><a href="#Undertow-Spring-boot" class="headerlink" title="Undertow Spring boot"></a>Undertow Spring boot</h3><p>Spring boot也支持使用Undertow替换掉tomcat，并且方法非常简单直接修改pom文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Undertow和Tomcat"><a href="#Undertow和Tomcat" class="headerlink" title="Undertow和Tomcat"></a>Undertow和Tomcat</h3><p>Tomcat是目前常用的服务器，Tomcat有三种运行模式：</p>
<ul>
<li>NIO: 利用java的异步io处理，并发性能更好。Tomcat8以上Linux系统中默认</li>
<li>BIO: 一个线程处理一个请求，但是并发性能不好。Tomcat7一下在Linux系统默认</li>
<li>APR: 基于JNI的形式调用Apache Http服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高Tomcat对静态文件的处理性能。Tomcat apr也是在Tomcat上运行高并发应用的首选模式。从操作系统级别来解决异步的IO问题。<br>通常Undertow的并发性能优于tomcat。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/09/undertow/" data-id="ckaxh3uy0001nykw7ni4ij746" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/08/29/池技术/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          池技术
        
      </div>
    </a>
  
  
    <a href="/2018/03/05/double精度问题/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">double精度问题</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-Spring/">JAVA Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Spring/">Java Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-JAVA/">Spring JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础/">基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JAVA/" style="font-size: 20px;">JAVA</a> <a href="/tags/JAVA-Spring/" style="font-size: 10px;">JAVA Spring</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/Java-Spring/" style="font-size: 10px;">Java Spring</a> <a href="/tags/Spring-JAVA/" style="font-size: 10px;">Spring JAVA</a> <a href="/tags/协议/" style="font-size: 10px;">协议</a> <a href="/tags/基础/" style="font-size: 13.33px;">基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/03/Java的枚举/">java的枚举</a>
          </li>
        
          <li>
            <a href="/2019/02/02/Java集合之EnumMap/">Java集合之EnumMap</a>
          </li>
        
          <li>
            <a href="/2019/02/02/Java集合之HashSet/">Java集合之HashSet</a>
          </li>
        
          <li>
            <a href="/2019/01/25/Java集合之HashMap/">Java集合之HashMap</a>
          </li>
        
          <li>
            <a href="/2019/01/24/Java集合之Vector/">Java集合之Vector</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 HuangQiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>