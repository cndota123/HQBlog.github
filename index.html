<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>HQ BLOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="for me">
<meta property="og:type" content="website">
<meta property="og:title" content="HQ BLOG">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="HQ BLOG">
<meta property="og:description" content="for me">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HQ BLOG">
<meta name="twitter:description" content="for me">
  
    <link rel="alternate" href="/atom.xml" title="HQ BLOG" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HQ BLOG</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="w-java类加载和实例化中对象加载顺序" class="article article-type-w" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/java类加载和实例化中对象加载顺序/" class="article-date">
  <time datetime="2018-11-15T07:07:53.000Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/15/java类加载和实例化中对象加载顺序/">java类加载和实例化中对象加载顺序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/15/java类加载和实例化中对象加载顺序/" data-id="cjoi98zoq000mnww75dwu33lv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/hello-world/" class="article-date">
  <time datetime="2018-11-15T06:05:08.559Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/15/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/15/hello-world/" data-id="cjoi98zom000inww7fhfw8h7o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TCP-IP协议" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/06/TCP-IP协议/" class="article-date">
  <time datetime="2018-09-06T14:04:47.000Z" itemprop="datePublished">2018-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/06/TCP-IP协议/">TCP/IP协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><p>TCP/IP协议通常指存在于OSI模型中一个协议簇，并不只是TCP、IP协议，其中我们常见的属于TCP/IP协议簇的协议有TELENT,FTP,HTTP,SMTP,DNS,TCP,UDP,IP,ICMP,ARP,RARP等协议。</p>
<h4 id="OSI七层模型和TCP-IP的四层模型"><a href="#OSI七层模型和TCP-IP的四层模型" class="headerlink" title="OSI七层模型和TCP/IP的四层模型"></a>OSI七层模型和TCP/IP的四层模型</h4><p>OSI(Open System Interconnect)七层模型从低到高依次是：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。是不同计算机之间互联通信的参考模型。<br>TCP/IP协议不完全符合OSI七层模型，它有四层从低到高依次是：网络接口层，网络层，传输层，应用层。<br>不过二者也是可以近似的对应起来，通常TCP/IP协议的一层对应OSI的一层或多层。</p>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>socket(套接字)是TCP/IP协议中网络通信的基本单元，包含了网络通信必须的五种信息：连接使用的协议，本地主机的ip地址，本地进程的协议端口，远程主机的ip地址，远程进程的端口。操作系统提供socket api提供应用程序来使用TCP/IP协议进行通信。</p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>关于TCP/IP协议簇，TCP协议是较为底层但是我们又非常熟悉的一个协议，他也是很多协议的基础。TCP协议是传输层协议，是一个长连接通信协议。</p>
<h4 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h4><p>16位源端口号：16位的源端口中包含初始化通信的端口。源端口和源IP地址的作用是标识报文的返回地址。</p>
<p>16位目的端口号：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。</p>
<p>32位序号：32位的序列号由接收端计算机使用，重新分段的报文成最初形式。序号随着通信的进行不断增加，达到最大时从0重新递增。TCP是面向字节流的，传送的字节流起始序号在建立连接时确定，序号指的是本报文发送数据的第一个字节的序号，例如一个报文序号是101,携带的数据是100字节，那么下个报文的序号就应该是201。当SYN出现，序列码实际上是初始序列码（Initial Sequence Number，ISN），而第一个数据字节是ISN+1。这个序列号（序列码）可用来补偿传输中的不一致。</p>
<p>32位确认序号：32位的序列号由接收端计算机使用，重组分段的报文成最初形式。如果设置了ACK控制位，这个值表示一个准备接收的包的序列码。</p>
<p>4位首部长度：4位包括TCP头大小，指示何处数据开始。</p>
<p>保留（6位）：6位值域，这些位必须是0。为了将来定义新的用途而保留。</p>
<p>标志：6位标志域。表示为：紧急标志、有意义的应答标志、推、重置连接标志、同步序列号标志、完成发送数据标志。按照顺序排列是：URG、ACK、PSH、RST、SYN、FIN。</p>
<p>16位窗口大小：用来表示想收到的每个TCP数据段的大小。TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16字节字段，因而窗口大小最大为65535字节。</p>
<p>16位校验和：16位TCP头。源机器基于数据内容计算一个数值，收信息机要与源机器数值 结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。</p>
<p>16位紧急指针：指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段。</p>
<p>选项：长度不定，但长度必须为1个字节。如果没有选项就表示这个1字节的域等于0。</p>
<p>数据：该TCP协议包负载的数据。</p>
<p>在上述字段中，6位标志域的各个选项功能如下。</p>
<p>URG：紧急标志。紧急标志为”1”表明该位有效。<br>ACK：确认标志。表明确认编号栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号（w+1）为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。<br>PSH：推标志。该标志置位时，接收端不将该数据进行队列处理，而是尽可能快地将数据转由应用处理。在处理Telnet或rlogin等交互模式的连接时，该标志总是置位的。<br>RST：复位标志。用于复位相应的TCP连接。<br>SYN：同步标志。表明同步序列编号栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端（一般是客户端）的初始序列编号。在这里，可以把TCP序列编号看作是一个范围从0到4，294，967，295的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号。<br>FIN：结束标志。</p>
<h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>建立一个TCP连接需要三次握手，这三次握手其实TCP建立连接时发送的三个包，TCP连接的建立由client触发，具体流程如下：<br>1.第一次握手：client将标志位SYN置为1,随机产生一个seq=J,并将该数据发送给Server，client进入SYN_SENT状态，等待server确认。<br>2.第二次握手：server收到包后通过SYN=1知道client请求建立连接，server将标志位SYN和ACK都置为1,ack(确认编号)=j+1,随机产生一个值seq=k，发送给client，server进入SYN_RCVD状态。<br>3.第三次握手：client接受到数据包之后检查ack是不是等于j+1，ACK是否为1，如果正确将ACK置为1，ack=k+1,将数据包发送给server，client进入ESTABLISHED状态，server同样检查ACK，ack如果正确，server进入ESTABLISHED状态，自此连接建立。</p>
<p>SYN攻击：在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。</p>
<h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p>终止一个TCP连接需要四次挥手，同理这个过程要发4个包，TCP连接的终止可以由server或者client任意一端发起，由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，流程如下：<br>1.第一次挥手：client发送一个FIN,用来关闭client到server的数据传输，client进入FIN_WAIT_1状态。<br>2.第二次挥手：server收到一个FIN，发送一个ack给client，确认序号为收到序号+1，server进入CLOSE_WAIT状态，client进入FIN_WAIT_2状态。<br>3.第三次挥手：server发送一个FIN，用来关闭server到client的数据传输，server进入LAST_ACK状态。<br>4.第四次挥手：client收到FIN后，client进入TIME_WAIT状态，接着发送一个ack给server，确认序号为收到序号+1，server进入CLOSED状态。自此连接终止。<br>之所以建立连接是三次握手而终止需要四次握手是因为，在对方提出终止连接即发送FIN之后，己方还可以继续发送数据，第一次发送ack只是说明已经知道对方提出终止连接，在己方发送FIN之后，双方就没有了正式数据交互，只是在执行终止连接的流程。多了这一次就是因为双方关于终止连接并不是立刻终止的。</p>
<p>TIME_WAIT状态变成CLOSED状态至少需要2MSL(MSL:最大报文段生存时间)的原因：<br>1.保证TCP协议的全双工连接能可靠关闭，如过client直接进入CLOSED状态，而由于其他原因server没有收到最后的ack报文，server会继续发送FIN报文，但是client已经是CLOSED状态，就会找不到对应连接，server就会收到RST，server就会认为连接错误报错，这样虽然没有数据错误，但是不符合可靠连接的要求，所以client会在2MSL后才由TIME_WAIT进入CLOSED状态。<br>2.保证这次连接的重复数据从网络中消失，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>Hyper Text Transfer Protocol(超文本传输协议)是万维网服务器传输超文本到本地的网络传输协议，所有www文件都必须遵循，是位于应用层的通信协议。<br>HTTP协议有如下特点：<br>1.支持B/S,C/S模式<br>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。<br>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。<br>4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。<br>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/06/TCP-IP协议/" data-id="cjoi98zp6000znww741oz29p7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java-NIO" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/03/Java-NIO/" class="article-date">
  <time datetime="2018-09-03T14:30:14.000Z" itemprop="datePublished">2018-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/03/Java-NIO/">Java NIO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>I/O通常指计算机中数据的输入和输出，一般涉及到网络和CPU、CPU与存储器之间或其他种类的数据交互，为了解决由于输入端和输出端的速度或者同步而产生问题而诞生一些I/O模型。</p>
<h3 id="5种模型"><a href="#5种模型" class="headerlink" title="5种模型"></a>5种模型</h3><p>在《Unix网络编程》中提到了5种I/O模型。</p>
<ul>
<li><p>阻塞IO模型：<br>  当用户线程发起I/O请求之后，内核会查看数据是否就绪，如果没有就等待数据就绪，用户线程处于阻塞状态，交出cpu，数据就绪之后，内核将数据拷贝给用户线程并返回结果，用户线程解除阻塞状态。</p>
</li>
<li><p>非阻塞IO模型<br>  用户线程发起I/O请求之后立刻返回结果来得知数据是否就绪，如果未就绪循环发起请求，当内核准备好数据后，再次得到请求就会将数据返回给用户线程。但是这种模型不释放cpu，cpu占用率高。</p>
</li>
<li><p>多路复用IO模型<br>  在多路复用IO模型中，有一个线程不断去轮询多个socket状态，只有当socket真正有读写事件，才真正调用实际的I/O操作，只用一个线程管理socket，减少线程创建维护销毁的开销，相对于非阻塞IO模型，通过一个专门的线程轮询效率更高。不过对于IO事件是逐一响应，当事件响应体很大时会影响后续事件响应。</p>
</li>
<li><p>信号驱动IO模型<br>  用户发起一个I/O请求，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当数据就绪时内核发送一个信号给用户线程，然后用户进程在信号函数中进行I/O操作。</p>
</li>
<li><p>异步IO模型<br>  用户线程发起I/O请求之后就可以执行其他任务，内核收到I/O请求之后立刻返回请求已经成功发起，然后内核在数据就绪后拷贝到用户线程并通知用户线程已经完成了I/O操作，用户线程就可以使用这些数据了。这种IO模型需要操作系统支持。</p>
</li>
</ul>
<p>这5中模型中，前四种都属于同步IO,最后一种是异步IO，因为在前四种内核将数据拷贝到用户进程时都会阻塞用户进程。(java 7提供了Asynchronous IO)</p>
<h3 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h3><p>java NIO是java 4提供的I/O新API。java NIO就是基于上述多路复用IO模型。</p>
<h4 id="NIO中的重要概念"><a href="#NIO中的重要概念" class="headerlink" title="NIO中的重要概念"></a>NIO中的重要概念</h4><ul>
<li><p>Channel(通道)：传统IO中stream是单向的，例如java InputStream只能读，OutputStream只能写，channel是双向既可以读也可以写。</p>
</li>
<li><p>Buffer(缓冲区)：NIO中读写的数据都放在Buffer中。</p>
</li>
<li><p>Selector(选择器)：Selector用来轮询每个注册的Channel，有IO事件发生便对相应Channel进行处理。</p>
</li>
</ul>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>和InputStream，OutputStream一样java也提供了多种channel，常用的有：</p>
<ul>
<li>FileChannel，文件的读写。</li>
<li>SocketChannel，TCP通信数据的读写。</li>
<li>ServerSocketChannel，监听客户端发起TCP连接为每一个TCP连接创建一个SocketChannel来进行数据读写。</li>
<li>DatagramChannel，UDP通信数据的读写。<br>下面是一个通过FileChannel来读写文件内容的demo<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="keyword">boolean</span> hasFile = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">    hasFile = file.createNewFile();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hasFile) &#123;</span><br><span class="line">    FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">    FileChannel channel = outputStream.getChannel();</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    String txt = <span class="string">"one two three"</span>;</span><br><span class="line">    byteBuffer.put(txt.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    channel.write(byteBuffer);</span><br><span class="line">    byteBuffer.compact();</span><br><span class="line">    byteBuffer.put(<span class="string">"123"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    channel = inputStream.getChannel();</span><br><span class="line">    channel.read(byteBuffer);</span><br><span class="line">    System.out.printf(<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">    channel.close();</span><br><span class="line">    inputStream.close();</span><br><span class="line">    outputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>一个用于特定基本类型的容器，java NIO中所有缓冲区实现类继承自Buffer这个抽象类，常用子类有ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。<br>Buffer的作用是将channel数据读到buffer中或者将Buffer数据写入Channel中。</p>
<h5 id="Buffer重要概念"><a href="#Buffer重要概念" class="headerlink" title="Buffer重要概念"></a>Buffer重要概念</h5><ul>
<li><p>capacity：容量，表示缓冲区容量，不能为负，且创建后不能更改</p>
</li>
<li><p>limit：索引中limit之后的数据不可读写</p>
</li>
<li><p>position：下一个要做读写操作的索引。</p>
</li>
<li><p>mark：标记后的索引，可以通过reset方法恢复position到这里。</p>
</li>
</ul>
<p>以上四种属性需要满足：mark&lt;=position&lt;=limit&lt;=capacity。</p>
<h5 id="Buffer的创建"><a href="#Buffer的创建" class="headerlink" title="Buffer的创建"></a>Buffer的创建</h5><ul>
<li><p>非直接创建：ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //大小是1024个字节，创建后position=0，limit=1024,capacity=1024</p>
</li>
<li><p>直接创建：ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024);</p>
</li>
<li><p>wrap方法：char[] charArray = new char[10]; CharBuffer charBuffer = CharBuffer.wrap(charArray);</p>
</li>
</ul>
<p>第一种内存开销发生在jvm中，第二种内存是系统分配。java程序在获取外部数据会由系统拷贝给jvm，第二种方法避免了这个操作，但是系统内存分配更耗时，所以缓冲区越大第一种效率越高，通常可以直接使用第一种，第三种相对前两种最大的区别是他的内存空间是别人提供的，二者数据的变动互相影响。</p>
<h5 id="Buffer的复制"><a href="#Buffer的复制" class="headerlink" title="Buffer的复制"></a>Buffer的复制</h5><ul>
<li><p>duplicate方法：浅拷贝，两个缓冲区共享数据，基础属性互相独立。</p>
</li>
<li><p>asReadOnlyBuffer方法：生成一个只读缓冲区，基本和duplicate方法一致</p>
</li>
<li><p>slice方法：分割缓冲区，新缓冲区和原缓冲区共享剩余空间，capacity(新)=limit(原)-position(原)</p>
</li>
</ul>
<h5 id="Buffer的操作"><a href="#Buffer的操作" class="headerlink" title="Buffer的操作"></a>Buffer的操作</h5><ul>
<li><p>读写：get()读，put()写</p>
</li>
<li><p>remaining():返回剩余空间大小(limit-position)</p>
</li>
<li><p>hasRemaining():返回从当前位置到上界有没有数据</p>
</li>
<li><p>flip():翻转，切换为读就绪状态，在channel读buffer数据前使用</p>
</li>
<li><p>compact():压缩，丢弃已经读取过的数据，将保留的数据填充到顶部</p>
</li>
<li><p>mark():标记，mark=position。</p>
</li>
<li><p>比较：equals(),compareTo(),都有Buffer实现，前者允许比较不同类型Buffer，后者不行</p>
</li>
</ul>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>Selector是SelectableChannel的多路复用器，继承SelectableChannel可以注册在Selector上由Selector监控。<br>Channel注册在Selector时返回一个SelectionKey对象，有如下属性</p>
<ul>
<li>interestSet，事件集合</li>
<li>ready集合，已就绪通道集合</li>
<li>Channel</li>
<li>Selector</li>
<li>附加的对象（可选），可以在注册时绑定，也可以用attach()方法，绑定的对象可以用attachment()方法取出。注意这个对象垃圾回收器不会回收一旦不使用就清楚。</li>
</ul>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><ul>
<li>SelectionKey.OP_CONNECT(1),连接</li>
<li>SelectionKey.OP_ACCEPT(4),接收</li>
<li>SelectionKey.OP_READ(8),读</li>
<li>SelectionKey.OP_WRITE(16),写</li>
</ul>
<p>多个事件用|连接，例如int key = SelectionKey.OP_CONNECT|SelectionKey.OP_ACCEPT.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断事件是否存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">int</span> interestSet = selectionKey.interestOps();  </span><br><span class="line">	<span class="keyword">boolean</span> isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;</span><br><span class="line">	<span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;  </span><br><span class="line">	<span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;  </span><br><span class="line">	<span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p>
<p>也可以用如下方法判断就绪事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();  </span><br><span class="line">selectionKey.isConnectable();  </span><br><span class="line">selectionKey.isReadable();  </span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure></p>
<h5 id="Select方法"><a href="#Select方法" class="headerlink" title="Select方法"></a>Select方法</h5><ul>
<li>select()：阻塞到至少有一个通道就绪。</li>
<li>select(long timeout):同上，但是最长阻塞时间为timeout毫秒</li>
<li>selectNow():非阻塞，只要有通道就绪就立刻返回。<br>select()方法返回的int值表示有多少通道已经就绪,是自上次调用select()方法后有多少通道变成就绪状态。</li>
</ul>
<h4 id="JAVA-NIO实现socket通信"><a href="#JAVA-NIO实现socket通信" class="headerlink" title="JAVA NIO实现socket通信"></a>JAVA NIO实现socket通信</h4><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/dolphin0520/p/3919162.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3919162.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/03/Java-NIO/" data-id="cjoi98zo70004nww75r1owpt3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-池技术" class="article article-type-w" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/29/池技术/" class="article-date">
  <time datetime="2018-08-29T14:50:28.000Z" itemprop="datePublished">2018-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/29/池技术/">池技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="池技术"><a href="#池技术" class="headerlink" title="池技术"></a>池技术</h3><p>就是将以后要用的资源提前创建，保存起来，提供使用，避免后面频繁创建和销毁这些资源的开销。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>java中线程池的实现就是同过一个线程池对象，在这个线程池中保存着已经创建好的线程，在平时是sleep状态，需要使用时唤醒，处理完请求后继续睡眠</p>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><h3 id="HTTP连接池"><a href="#HTTP连接池" class="headerlink" title="HTTP连接池"></a>HTTP连接池</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/29/池技术/" data-id="cjoi98zow000vnww7zofncukv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-undertow" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/09/undertow/" class="article-date">
  <time datetime="2018-05-09T14:04:26.000Z" itemprop="datePublished">2018-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/09/undertow/">undertow</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="undertow简介"><a href="#undertow简介" class="headerlink" title="undertow简介"></a>undertow简介</h2><p>Undertow是RedHat的开源产品，是WildFly8（JBoos）默认的Web服务器。</p>
<p>官方定义：<br>Undertow is a flexible performant web server written in java, providing both blocking and non-blocking API’s based on NIO(Undertow是一个用java编写的灵活的高性能Web服务器，提供基于NIO的阻塞和非阻塞API.).</p>
<p>总结它有以下个特点：</p>
<ul>
<li>HTTP/2 Support<ul>
<li>Undertow非常轻量级，Undertow核心jar包在1Mb以下。它在运行时也是轻量级的，有一个简单的嵌入式服务器使用少于4Mb的堆空间</li>
</ul>
</li>
<li>HTTP Upgrade Support（支持http升级）<ul>
<li>支持HTTP升级，允许多个协议通过HTTP端口进行多路复用</li>
</ul>
</li>
<li>Web Socket Support（支持WebScoket）<ul>
<li>Undertow提供对Web Socket的全面支持，包括JSR-356支持</li>
</ul>
</li>
<li>Servlet 4.0<ul>
<li>Undertow提供对Servlet 4.0的支持，包括对嵌入式servlet的支持。 还可以在同一部署中混合Servlet和本机Undertow非阻塞处理程序</li>
</ul>
</li>
<li>Embeddable（可嵌入的）<ul>
<li>Undertow可以嵌入在应用程序中或独立运行，只需几行代码</li>
</ul>
</li>
<li>Flexible（灵活性）<ul>
<li>Undertow框架jar包： undertow-core.jar undertow-servlet.jar,不需要的库可以不用</li>
</ul>
</li>
</ul>
<h3 id="undertow设计初衷"><a href="#undertow设计初衷" class="headerlink" title="undertow设计初衷"></a>undertow设计初衷</h3><ol>
<li>更好的满足JBoss应用服务器的集成需要。Tomcat最初设计于10年前，体系结构没有办法进行灵活的修改。在和JBoss应用服务器集成时，需要写大量的组合代码使得Tomcat和JBossAS协同工作。</li>
<li>嵌入式需求。不论是JBoss应用服务器本身，还是目前微服务(MicroService)的设计倾向，都希望能够web容器足够小而精悍，可以嵌入使用，而Tomcat很难满足这个需要。</li>
<li>支持Websocket协议需求和NIO，异步化思路等的促进。异步通信框架在并发连接数，性能的优异表现促使开发人员想重新按照新的思路来设计一款Web服务器。</li>
</ol>
<h3 id="undertow性能"><a href="#undertow性能" class="headerlink" title="undertow性能"></a>undertow性能</h3><p>在Undertow刚发布beta版时，参加了由Techempower设计的著名框架集合性能测试竞赛，在纯文本EC2服务上一举拿下第一<br><a href="http://www.techempower.com/benchmarks/#section=data-r6&amp;hw=ec2&amp;test=plaintext" target="_blank" rel="noopener">Web Framework Benchmarks</a></p>
<h2 id="undertow使用"><a href="#undertow使用" class="headerlink" title="undertow使用"></a>undertow使用</h2><h3 id="一个简单的undertow服务"><a href="#一个简单的undertow服务" class="headerlink" title="一个简单的undertow服务"></a>一个简单的undertow服务</h3><p>下面是官方文档给出的一个简单的使用demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Undertow server = Undertow.builder().addHttpListener(<span class="number">8090</span>,<span class="string">"localhost"</span>)</span><br><span class="line">            .setHandler(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    httpServerExchange.getResponseHeaders().put(Headers.CONTENT_TYPE,<span class="string">"text/plain"</span>);</span><br><span class="line">                    httpServerExchange.getResponseSender().send(<span class="string">"hello world"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).build();</span><br><span class="line">    server.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Undertow.builder()快速配置和启动Undertow服务器，addHttpListener()告诉服务器Undertow服务器在端口8090绑定到localhost，HttpHandler是一个内置处理程序接口，它有各种各样的实现来实现不同功能。在这个demo中修改response的header和body返回hello world。</p>
<h3 id="手动组装服务器"><a href="#手动组装服务器" class="headerlink" title="手动组装服务器"></a>手动组装服务器</h3><p>Undertow.builder()提供了一个快捷的服务器构建方式，不过我们也可以手动组装服务器，这样有更大的自由度。<br>官网对于这种方式介绍含有以下描述：</p>
<ul>
<li>完全控制所有选项</li>
<li>能够为每个listener使用不同的缓冲池和工作者</li>
<li>XnioWorker实例可以在不同的服务器实例之间共享</li>
<li>缓冲池可以在不同的服务器实例之间共享</li>
<li>听众可以被赋予不同的根处理程序</li>
</ul>
<p>不过在大多数情况下，这种控制级别是不必要的，最好是简单地使用构建器API。</p>
<p>下面给出一个Http listener类型的demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Xnio xnio = Xnio.getInstance();</span><br><span class="line">XnioWorker worker = xnio.createWorker(OptionMap.builder()</span><br><span class="line">        .set(Options.WORKER_IO_THREADS,<span class="number">8</span>)</span><br><span class="line">        .set(Options.WORKER_TASK_CORE_THREADS,<span class="number">40</span>)</span><br><span class="line">        .set(Options.WORKER_TASK_MAX_THREADS,<span class="number">10</span>)</span><br><span class="line">        .set(Options.TCP_NODELAY,<span class="keyword">true</span>)</span><br><span class="line">        .getMap()</span><br><span class="line">);</span><br><span class="line">OptionMap socketOptions = OptionMap.builder()</span><br><span class="line">        .set(Options.WORKER_IO_THREADS, <span class="number">5</span>)</span><br><span class="line">        .set(Options.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">        .set(Options.REUSE_ADDRESSES, <span class="keyword">true</span>)</span><br><span class="line">        .getMap();</span><br><span class="line">Pool&lt;ByteBuffer&gt; buffers = <span class="keyword">new</span> ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR,<span class="number">1024</span>, <span class="number">16</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">HttpOpenListener openListener = <span class="keyword">new</span> HttpOpenListener(buffers,OptionMap.builder().set(UndertowOptions.BUFFER_PIPELINED_DATA,<span class="keyword">true</span>)</span><br><span class="line">        .addAll(socketOptions).getMap());</span><br><span class="line">openListener.setRootHandler(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        httpServerExchange.getResponseHeaders().put(Headers.CONTENT_TYPE,<span class="string">"text/plain"</span>);</span><br><span class="line">        httpServerExchange.getResponseSender().send(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ChannelListener&lt;AcceptingChannel&lt;StreamConnection&gt;&gt; channelListener = ChannelListeners.openListenerAdapter(openListener);</span><br><span class="line">AcceptingChannel&lt;? extends StreamConnection&gt; server = worker.createStreamConnectionServer(<span class="keyword">new</span> InetSocketAddress(Inet4Address.getByName(<span class="string">"localhost"</span>),<span class="number">8098</span>),channelListener,socketOptions);</span><br><span class="line">server.resumeAccepts();</span><br></pre></td></tr></table></figure></p>
<p>上述demo实现功能和利用Undertow.buider()构建的服务器实现能相同。<br>其中有几个比较重要的概念：</p>
<ol>
<li>WORKER_IO_THREADS:要创建的IO线程数，IO线程执行非堵塞任务，并且不应该执行阻塞操作，因为他们负责多个连接，一旦堵塞有的连接就要挂起，每个cpu内核有两个IO线程是合理的</li>
<li>WORKER_TASK_CORE_THREADS:工作线程阻塞任务线程池中的线程数，当执行堵塞操作时，任务分配给该线程池中的线程</li>
</ol>
<h3 id="undertow架构"><a href="#undertow架构" class="headerlink" title="undertow架构"></a>undertow架构</h3><p>通过以上demo对于undertow也有了一个初步的了解。Undertow独特之处在于它没有global container，对于global container我的理解是例如tomcat就利用容器来处理用户请求，至于是不是一个容器管理所有功能还是多个容器协同工作不作考虑，在undertow中服务器由嵌入式应用程序组装而成，这使得Undertow非常灵活，嵌入式应用程序基本可以选择他们需要的那一部分，然后合理组装。</p>
<p>上面demo也体现了这一点我们只是获取Xnio实例，创建了一些操作实例来处理请求，并没有新建容器或是配置容器功能，undertow仅仅是按规则将一些功能类组合起来使用。<br>Undertow服务器基本由三件事组成，一个（或多个）XNIO工作者实例，一个或多个连接器和处理传入请求的处理程序链。</p>
<h3 id="undertow处理程序"><a href="#undertow处理程序" class="headerlink" title="undertow处理程序"></a>undertow处理程序</h3><p>业务功能和服务器逻辑功能的实现通常通过处理程序来实现，处理的程序接口代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange exchange)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>handleRequest方法是处理程序的具体实现，HttpServerExchange有请求的所有上下文信息。<br>如下demo中我们可以自定义一个HttpHandler<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpHandler</span> <span class="keyword">implements</span> <span class="title">HttpHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpString header;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpHandler next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHttpHandler</span><span class="params">(<span class="keyword">final</span> HttpHandler next,<span class="keyword">final</span> String header,<span class="keyword">final</span> String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.header = <span class="keyword">new</span> HttpString(header);</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        httpServerExchange.getResponseHeaders().put(header,value);</span><br><span class="line">        next.handleRequest(httpServerExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    openListener.setRootHandler(<span class="keyword">new</span> MyHttpHandler(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            httpServerExchange.getResponseSender().send(<span class="string">"hello world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">"CONTENT_TYPE"</span>,<span class="string">"text/plain"</span>));</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>上述demo实现的功能和之前demo相同，同时这也是一种处理程序链实现方案。<br>另外一种是通过HttpServerExchange的dispatch方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">openListener.setRootHandler(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        httpServerExchange.getResponseHeaders().put(Headers.CONTENT_TYPE,<span class="string">"text/plain"</span>);</span><br><span class="line">        <span class="keyword">if</span> (httpServerExchange.isInIoThread())&#123;</span><br><span class="line">            httpServerExchange.dispatch(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    httpServerExchange.startBlocking();</span><br><span class="line">                    httpServerExchange.getOutputStream().write(<span class="string">"hello "</span>.getBytes());</span><br><span class="line">                    httpServerExchange.dispatch(<span class="keyword">new</span> HttpHandler() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange httpServerExchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            httpServerExchange.getOutputStream().write(<span class="string">"world"</span>.getBytes());</span><br><span class="line">                            httpServerExchange.endExchange();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>同样这个服务器也实现了返回hello world的功能。</p>
<h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>Undertow有四种监听器（官网说有5种但也只给了四个）：</p>
<ul>
<li>HTTP / 1.1</li>
<li>HTTPS</li>
<li>AJP</li>
<li>HTTP / 2<br>他们的差别主要在构建的时候listener类型的选择，其中比较典型是HTTP2需要ALPN的支持（java 9自带），同时HTTP2支持Http Upgrade</li>
</ul>
<h3 id="Undertow-Servlet"><a href="#Undertow-Servlet" class="headerlink" title="Undertow Servlet"></a>Undertow Servlet</h3><p>Undertow也可以配合servlet使用，这里提供一个简单的demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    DeploymentInfo servletBuilder = Servlets.deployment()</span><br><span class="line">            .setClassLoader(ServletServer.class.getClassLoader())</span><br><span class="line">            .setContextPath(<span class="string">"/servlet"</span>)</span><br><span class="line">            .setDeploymentName(<span class="string">"test.war"</span>)</span><br><span class="line">            .addServlets(</span><br><span class="line">                    Servlets.servlet(<span class="string">"myServlet"</span>,MyServlet.class)</span><br><span class="line">                    .addInitParam(<span class="string">"message"</span>,<span class="string">"MyServlet"</span>)</span><br><span class="line">                    .addMapping(<span class="string">"/myServlet"</span>)</span><br><span class="line">            );</span><br><span class="line">    DeploymentManager manager = Servlets.defaultContainer().addDeployment(servletBuilder);</span><br><span class="line">    manager.deploy();</span><br><span class="line">    PathHandler path = Handlers.path(Handlers.redirect(<span class="string">"/myapp"</span>))</span><br><span class="line">            .addPrefixPath(<span class="string">"/myapp"</span>, manager.start());</span><br><span class="line">    Undertow server = Undertow.builder().addHttpListener(<span class="number">8094</span>,<span class="string">"localhost"</span>).setHandler(path).build();</span><br><span class="line">    server.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MyServlet是自己定义的一个servlet<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        response.setHeader(<span class="string">"CONTENT_TYPE"</span>,<span class="string">"text/plain"</span>);</span><br><span class="line">        OutputStream out = response.getOutputStream();</span><br><span class="line">        out.write(<span class="string">"hello world"</span>.getBytes());</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个demo功能也是返回hello world不过它配置了前缀路径和servlet匹配路径，所以访问路径和之前有所不同。</p>
<p>这只是Undertow配合servlet的一个小小的应用，Undertow还支持各种扩展功能，例如资源管理器，认证机制等，在这就不一一叙述，在<a href="http://undertow.io/undertow-docs/undertow-docs-2.0.0/index.html#undertow-servlet" target="_blank" rel="noopener">官方文档</a>有相关描述</p>
<h3 id="Undertow-Spring-boot"><a href="#Undertow-Spring-boot" class="headerlink" title="Undertow Spring boot"></a>Undertow Spring boot</h3><p>Spring boot也支持使用Undertow替换掉tomcat，并且方法非常简单直接修改pom文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Undertow和Tomcat"><a href="#Undertow和Tomcat" class="headerlink" title="Undertow和Tomcat"></a>Undertow和Tomcat</h3><p>Tomcat是目前常用的服务器，Tomcat有三种运行模式：</p>
<ul>
<li>NIO: 利用java的异步io处理，并发性能更好。Tomcat8以上Linux系统中默认</li>
<li>BIO: 一个线程处理一个请求，但是并发性能不好。Tomcat7一下在Linux系统默认</li>
<li>APR: 基于JNI的形式调用Apache Http服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高Tomcat对静态文件的处理性能。Tomcat apr也是在Tomcat上运行高并发应用的首选模式。从操作系统级别来解决异步的IO问题。<br>通常Undertow的并发性能优于tomcat。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/09/undertow/" data-id="cjoi98zp80011nww7garlahg5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-double精度问题" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/double精度问题/" class="article-date">
  <time datetime="2018-03-05T08:25:40.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/05/double精度问题/">double精度问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近写的程序很多都有关订单价格计算，其中设计到double的运算，想起来double有可能精度丢失，因此研究了一下相关问题。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>IEEE 754标准是IEEE二进制浮点数算术标准，很多语言和浮点运算器的标准就是IEEE 754。首先来分析下IEEE 754小数的表示。<br>比如十进制的5.5在二进制中是小数点后101.1(假设小数点固定),可以很容易得出二进制转化成十进制就是对每位加权之后计算的结果，从个位即0位，每位的权值是2的当前位数的幂，位数左加右减。<br>反的来十进制转二进制，小数部分和整数分开，5用除2取余是101,0.5=1/2，即等于1/10(二进制)=0.1。(还可以用小数部分乘2的方法来转换)<br>但是假设小数部分是0.1,0.1=1/10=0.000110011…,这是一个无限循环的数，计算机的空间是有限的，一个数的大小也是有限的，因此碰到这种转成二进制是超过位数限制的数，在计算机中精度已经丢失了，<br>最后在转化成十进制的时候已经不是之前的数了(具体结果要看相关数据类型在该计算机或语言中定义的长度和舍入规则)。<br>以上是定点数，浮点数的公式 V = (-1)^s×M×2^E，这种表示方法小数点位置不固定，取值范围更大精确度也更高，但是还是没有解决精度丢失的问题(因为比如0.1这种数还是无法精确表示只能更加接近0.1的值)</p>
<h3 id="java中的精度丢失问题"><a href="#java中的精度丢失问题" class="headerlink" title="java中的精度丢失问题"></a>java中的精度丢失问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    double a = 0.1;</span><br><span class="line">    System.out.println(a*1);</span><br><span class="line">    System.out.println(&quot;&quot;+a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>0.1<br>0.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    double a = 0.1;</span><br><span class="line">    System.out.println(a*a);</span><br><span class="line">    System.out.println(&quot;&quot;+a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br>0.010000000000000002<br>0.1</p>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>在java为防止计算中的精度丢失问题提供了BigDecimal这个类来进行相关运算。BigDecimal将数据转换成String类型，并提供了加、减、乘、除，其中除法是根据提供精度要求来确定最终值。<br>另外为了防止double，float数据转换成BigDecimal对象时发生精度丢失，通常传入String。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    String money = &quot;0.1&quot;;</span><br><span class="line">    BigDecimal big = new BigDecimal(money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/05/double精度问题/" data-id="cjoi98zog000enww7xvudby18" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-netty的使用" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/28/netty的使用/" class="article-date">
  <time datetime="2018-02-28T09:15:50.000Z" itemprop="datePublished">2018-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/28/netty的使用/">netty的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/28/netty的使用/" data-id="cjoi98zos000pnww791g5ie8j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-Spring-Cloud研究" class="article article-type-w" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/28/Spring-Cloud研究/" class="article-date">
  <time datetime="2018-02-28T09:11:40.000Z" itemprop="datePublished">2018-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/28/Spring-Cloud研究/">Spring Cloud研究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/28/Spring-Cloud研究/" data-id="cjoi98zo90005nww77q7r8y6j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring-rest-doc体验" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/28/Spring-rest-doc体验/" class="article-date">
  <time datetime="2018-02-28T09:11:15.000Z" itemprop="datePublished">2018-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/28/Spring-rest-doc体验/">Spring rest doc体验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/28/Spring-rest-doc体验/" data-id="cjoi98zof000dnww7am4c8srw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-Spring/">JAVA Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Spring/">Java Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-JAVA/">Spring JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础/">基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JAVA/" style="font-size: 20px;">JAVA</a> <a href="/tags/JAVA-Spring/" style="font-size: 10px;">JAVA Spring</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Java-Spring/" style="font-size: 10px;">Java Spring</a> <a href="/tags/Spring-JAVA/" style="font-size: 10px;">Spring JAVA</a> <a href="/tags/协议/" style="font-size: 10px;">协议</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/15/java类加载和实例化中对象加载顺序/">java类加载和实例化中对象加载顺序</a>
          </li>
        
          <li>
            <a href="/2018/11/15/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/09/06/TCP-IP协议/">TCP/IP协议</a>
          </li>
        
          <li>
            <a href="/2018/09/03/Java-NIO/">Java NIO</a>
          </li>
        
          <li>
            <a href="/2018/08/29/池技术/">池技术</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 HuangQiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>