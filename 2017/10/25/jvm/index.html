<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>JVM | HQ BLOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JVMJVM是Java Virtual Machine，众所周知语言需要平台的支持，例如C语言有着不同运行平台，因此也需要编译成不同指令，这就需要不同编译器。Java通过Jvm来让Java代码在编译之后运行在Java虚拟机上从而实现跨平台而不需重复编译，也就是一次编译，到处运行。 JVM内存区域JVM的内部体系结构分为三部分：  类装载器（ClassLoader）子系统。 运行时数据区 执行引擎">
<meta name="keywords" content="JAVA">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://yoursite.com/2017/10/25/jvm/index.html">
<meta property="og:site_name" content="HQ BLOG">
<meta property="og:description" content="JVMJVM是Java Virtual Machine，众所周知语言需要平台的支持，例如C语言有着不同运行平台，因此也需要编译成不同指令，这就需要不同编译器。Java通过Jvm来让Java代码在编译之后运行在Java虚拟机上从而实现跨平台而不需重复编译，也就是一次编译，到处运行。 JVM内存区域JVM的内部体系结构分为三部分：  类装载器（ClassLoader）子系统。 运行时数据区 执行引擎">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-09-09T06:35:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM">
<meta name="twitter:description" content="JVMJVM是Java Virtual Machine，众所周知语言需要平台的支持，例如C语言有着不同运行平台，因此也需要编译成不同指令，这就需要不同编译器。Java通过Jvm来让Java代码在编译之后运行在Java虚拟机上从而实现跨平台而不需重复编译，也就是一次编译，到处运行。 JVM内存区域JVM的内部体系结构分为三部分：  类装载器（ClassLoader）子系统。 运行时数据区 执行引擎">
  
    <link rel="alternate" href="/atom.xml" title="HQ BLOG" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HQ BLOG</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-jvm" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/25/jvm/" class="article-date">
  <time datetime="2017-10-25T06:35:15.000Z" itemprop="datePublished">2017-10-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JVM
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>JVM是Java Virtual Machine，众所周知语言需要平台的支持，例如C语言有着不同运行平台，因此也需要编译成不同指令，这就需要不同编译器。<br>Java通过Jvm来让Java代码在编译之后运行在Java虚拟机上从而实现跨平台而不需重复编译，也就是一次编译，到处运行。</p>
<h2 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h2><p>JVM的内部体系结构分为三部分：</p>
<ul>
<li>类装载器（ClassLoader）子系统。</li>
<li>运行时数据区</li>
<li>执行引擎</li>
</ul>
<h3 id="类装载器"><a href="#类装载器" class="headerlink" title="类装载器"></a>类装载器</h3><p>类加载器负责加载程序中的类型（类和接口）并赋予唯一的名字。</p>
<p>Java虚拟机有三种类装载器：启动类加载器（BootstrapClassLoder），扩展类加载器（ExtensionClassLoader），系统类加载器（AppClassLoader）。</p>
<p>类装载器除了要定位和导入class文件外，还必须验证被导入类的正确性，为类变量分配并初始化内存，以及帮助解析符号引用。<br>操作顺序：</p>
<ol>
<li>装载（load）：通过一个类的完全限定查找此类字节码文件，并创建一个class对象。</li>
<li>连接（link）：执行验证，准备，以及解析（可选）<ol>
<li>验证（verify）确保导入类型的正确性并且不会危害虚拟机安全，主要包含四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。</li>
<li>准备（prepare）为类变量分配内存，并初始化成默认值（这里处理的是static变量，final修饰的编译时就分配了）</li>
<li>解析（resolve）把类型中的符号引用转化为直接引用</li>
</ol>
</li>
<li>初始化（Initialize）：把类变量初始化成正确值，成员变量也会初始化</li>
</ol>
<h4 id="启动类装载器"><a href="#启动类装载器" class="headerlink" title="启动类装载器"></a>启动类装载器</h4><p>启动类加载器是JVM自身需要的类，使用C++实现，是虚拟机自身一部分，负责将JAVA_HOME/lib路径下核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中（出于安全考虑Bootstrap只加载包名为java、javax、sun等开头的类）</p>
<h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><p>扩展类加载器是指sun.misc.Launcher$ExtClassLoader类用Java编写且他的父类加载器是Bootstrap，负责加载JAVA_HOME/lib/ext目录下或系统变量-Djava.ext.dir路径下类库。</p>
<h4 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h4><p>也叫应用程序加载器是指sun.misc.Launcher$AppClassLoader类，负责加载系统类路径java -classpath或-Djava.class.path路径下类库，通过ClassLoader#getSystemClassLoader()可以获取到该类加载器。</p>
<p>在必要时我们也可以自定义类加载器。</p>
<p>Java虚拟机对class文件采用按需加载的方式，在加载某个类的class文件时，java虚拟机采用双亲委派模式即把请求交由父类处理，它是一种任务委派模式。</p>
<h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式要求除了顶层的启动类加载器，其余类加载器都有自己的父类加载器，即所有任务向上委托，直至顶层加载器，若任务无法完成才让子加载器来完成。<br>好处：当父加载器已经加载了子加载器不用再加载一起，同时保证了java核心api不会被随意修改替换。</p>
<p>关于类加载器具体代码研究部分：<a href="/2017/10/26/JAVA类加载器/" title="JAVA类加载器">JAVA类加载器</a></p>
<h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p>执行引擎以指令为单位读取java字节码。<br>执行引擎可以通过一下工具翻译java字节码</p>
<ul>
<li>解释器：一条一条的读取，解释并执行字节码指令，解释速度快但是执行慢。</li>
<li>即时（Just-In-Time）编译器：先按照解释器方式运行在合适的时候把整段字节码翻译成本地代码，本地代码存在缓存中。<br>有的JVM还有自适应优化：对常使用的代码编译成本地代码（类似计算机系统中的高速cache）</li>
</ul>
<h3 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h3><ul>
<li>方法区域（Method Area）<br>在HotSpot中这块区域对应为PermanetGeneration，又称持久代、永久代。因为HotSpot中将GC分代收集扩展到了方法区<br>方法区域存放了所加载的类的信息、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，方法区域是全局共享的，在一定条件下他也会被GC,主要收集目标是常量池的回收和类型的卸载，当方法区域需要内存超出允许的大小会抛出OutOfMemory<br>运行时常量池是方法区的一部分，用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后放入。</li>
<li><p>java堆（Heap）<br>JVM用来存储对象实例以及数组值的区域。<br>堆是JVM中所有线程共享的，因此在上面分配对象的内存需要加锁，这也导致new的开销比较大。<br>Sun Hostpot JVM为了提升内存分配效率，对于所创建的线程都会分配一块独立的空间TLAB(Thread Local Allocation Buffer)，其大小由JVM根据运行的情况计算得出，在TLAB上分配对象不用加锁。<br>TLAB仅作用与新生代的Eden Space，因此在编写java程序是，多个小对象比大对象分配起来更高效。<br>堆中内存不够完成实例分配，也无法扩展时抛出OutOfMemoryError。</p>
</li>
<li><p>VMStack<br>虚拟机栈，线程私有，描述java方法执行的内存模型，平时大家聊的堆、栈，栈就是虚拟机栈，虚拟机只会对VMStack执行两种操作：以帧为单位的压栈或出栈。<br>每调用一个方法都会创建相应的栈帧(Stack Frame)，执行完毕、return和抛出异常都会导致出栈和释放内存。<br>帧是方法运行时的基础数据结构，后面会仔细分析。在虚拟机栈中如果线程请求的栈深度大于虚拟机所允许的，抛出StackOverflowError，如果允许虚拟机栈动态扩展，在无法申请到足够内存是抛出OutOfMemoryError。</p>
</li>
<li><p>ProgramCounter<br>程序计数器。当前字节码的行号，虚拟机模型概念中，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。每条线程都有一个独立的计数器，这是”线程私有”的内存区域。如果执行的是native方法，此时计数器的值为空(undefined)，这个内存区域是java中唯一没有规定OutOfMemoryError情况的区域。</p>
</li>
<li><p>NativemethodStack<br>本地方法栈。和虚拟机栈类似，不过是为了native方法服务的。</p>
</li>
</ul>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存不是虚拟机运行时数据区的内存，不是java虚拟机规范定义的内存区域，是java代码中直接调用native方法由系统生成的内存，在内存不足时抛出OutOfMemeoryError。</p>
<h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><p>Object obj = new Object();这行代码生成了一个Object实例，并提供一个变量obj来访问这个实例。下面从内存角度说明对象是如何访问的<br>首先Object obj会作为一个reference类型数据存储在java栈的本地变量表中，new Object()将在java堆中形成一块存储了Object类型所有实例数据值的结构化内存，另外在堆中必须包含能查到这个对象类型数据(如对象类型、父类、实现的接口、方法等)的地址信息，这些类型数据存储在方法区中。<br>当我们通过栈中的reference数据访问时，不同虚拟机有不同实现，主流的访问方法有两种：使用句柄和直接指针。</p>
<ul>
<li><p>使用句柄：java堆中划分一块内存作为句柄池，reference中存储对象的句柄地址，句柄中包含对象实例数据和类型数据各自的具体地址信息。优点：对象移动时只改变句柄的实例数据指针，reference本身不用更改。</p>
</li>
<li><p>直接指针：reference存储java堆中实例数据的指针，但是这种方式需要堆中能够得到类型数据的相关信息。优点：速度更快，减少一次从句柄池定位到实例数据的定位。HotSpot采取就是直接指针。</p>
</li>
</ul>
<h2 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h2><p>Sun的JVMGGenerationalCollecting：把对象分成年轻代（Young）、年老代（Tenured）、持久代（Perm）对于不同生命周期使用不同的算法。<br>通常我们说的JVM内存回收总是在指堆内存回收，确实只有堆中的内容是动态回收，所以年轻代和年老代都是指JVM的Heap空间，持久代是方法区。</p>
<ol>
<li>对年轻代（新生代）对象的回收称为minor GC</li>
<li>对年老代（旧生代）对象的回收称为Full GC</li>
<li>程序调用System.gc()强制执行的GC叫做Full GC</li>
</ol>
<p>对象的引用分成四种引用</p>
<ol>
<li>强引用也就是new生成的实例（该对象实例没有其他对象引用时才会回收，内存不足会报错）</li>
<li>软引用（内存不足时GC）</li>
<li>弱引用（GC时一定会被回收）</li>
<li>虚引用（随时被GC通常用来得知对象是否被GC）</li>
</ol>
<h3 id="Young"><a href="#Young" class="headerlink" title="Young"></a>Young</h3><p>年轻代分为三个区。一个Eden区，两个Survivor区。大部分对象在Eden区中生成。Enden区满的时候还存活的对象被复制到其中一个Survivor区，当这个区也满了，此区的存活对象复制到另一个Survivor区中。当另一个Survivor区也满了就把此时还存活的从前一个Survivor区中复制过来的对象复制到年老区。</p>
<h3 id="Tenured"><a href="#Tenured" class="headerlink" title="Tenured"></a>Tenured</h3><p>年老代存放从年轻代存活的对象，所以一般都是生命周期比较长得对象</p>
<h3 id="Perm"><a href="#Perm" class="headerlink" title="Perm"></a>Perm</h3><p>用来存放静态文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/25/jvm/" data-id="cjoi98zp70010nww7u2jwhlfi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/10/26/JAVA类加载器/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JAVA类加载器
        
      </div>
    </a>
  
  
    <a href="/2017/10/24/java随笔/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">java随笔</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-Spring/">JAVA Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Spring/">Java Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-JAVA/">Spring JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础/">基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JAVA/" style="font-size: 20px;">JAVA</a> <a href="/tags/JAVA-Spring/" style="font-size: 10px;">JAVA Spring</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Java-Spring/" style="font-size: 10px;">Java Spring</a> <a href="/tags/Spring-JAVA/" style="font-size: 10px;">Spring JAVA</a> <a href="/tags/协议/" style="font-size: 10px;">协议</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/15/java类加载和实例化中对象加载顺序/">java类加载和实例化中对象加载顺序</a>
          </li>
        
          <li>
            <a href="/2018/11/15/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/09/06/TCP-IP协议/">TCP/IP协议</a>
          </li>
        
          <li>
            <a href="/2018/09/03/Java-NIO/">Java NIO</a>
          </li>
        
          <li>
            <a href="/2018/08/29/池技术/">池技术</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 HuangQiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>